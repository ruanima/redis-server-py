'''
        #  Replication (master)
        #  Last SELECTed DB in replication output
        self.slaveseldb: int = 0
        # 全局复制偏移量（一个累计值）
        #  Global replication offset
        self.master_repl_offset: int = 0
        # 主服务器发送 PING 的频率
        #  Master pings the slave every N seconds
        self.repl_ping_slave_period: int = 0
        # backlog 本身
        #  Replication backlog for partial syncs
        self.repl_backlog: str = ''
        # backlog 的长度
        #  Backlog circular buffer size
        self.repl_backlog_size: int = 0
        # backlog 中数据的长度
        #  Backlog actual data length
        self.repl_backlog_histlen: int = 0
        # backlog 的当前索引
        #  Backlog circular buffer current offset
        self.repl_backlog_idx: int = 0
        # backlog 中可以被还原的第一个字节的偏移量
        self.repl_backlog_off: int = 0
        #  Replication offset of first byte in thebacklog buffer.
        # backlog 的过期时间
        self.repl_backlog_time_limit: int = 0
        #  Time without slaves after the backloggets released.
        # 距离上一次有从服务器的时间
        self.repl_no_slaves_since: int = 0
        #  We have no slaves since that time.Only valid if server.slaves len is 0.
        # 是否开启最小数量从服务器写入功能
        #  Min number of slaves to write.
        self.repl_min_slaves_to_write: int = 0
        # 定义最小数量从服务器的最大延迟值
        #  Max lag of <count> slaves to write.
        self.repl_min_slaves_max_lag: int = 0
        # 延迟良好的从服务器的数量
        #  Number of slaves with lag <= max_lag.
        self.repl_good_slaves_count: int = 0
        #  Replication (slave)
        # 主服务器的验证密码
        #  AUTH with this password with master
        self.masterauth: str = ''
        # 主服务器的地址
        #  Hostname of master
        self.masterhost: str = ''
        # 主服务器的端口
        #  Port of master
        self.masterport: int = 0
        # 超时时间
        #  Timeout after N seconds of master idle
        self.repl_timeout: int = 0
        # 主服务器所对应的客户端
        #  Client that is master for this slave
        self.master: RedisClient = None
        # 被缓存的主服务器，PSYNC 时使用
        #  Cached master to be reused for PSYNC.
        self.cached_master: RedisClient = None
        #  Timeout for synchronous I/O calls
        self.repl_syncio_timeout: int = 0
        # 复制的状态（服务器是从服务器时使用）
        #  Replication status if the instance is a slave
        self.repl_state: int = 0
        # RDB 文件的大小
        #  Size of RDB to read from master during sync.
        self.repl_transfer_size = 0
        # 已读 RDB 文件内容的字节数
        #  Amount of RDB read from master during sync.
        self.repl_transfer_read = 0
        # 最近一次执行 fsync 时的偏移量
        # 用于 sync_file_range 函数
        #  Offset when we fsync-ed last time.
        self.repl_transfer_last_fsync_off = 0
        # 主服务器的套接字
        #  Slave -> Master SYNC socket
        self.repl_transfer_s: int = 0
        # 保存 RDB 文件的临时文件的描述符
        #  Slave -> Master SYNC temp file descriptor
        self.repl_transfer_fd: int = 0
        # 保存 RDB 文件的临时文件名字
        #  Slave-> master SYNC temp file name
        self.repl_transfer_tmpfile: str = ''
        # 最近一次读入 RDB 内容的时间
        #  Unix time of the latest read, for timeout
        self.repl_transfer_lastio: int = 0
        #  Serve stale data when link is down?
        self.repl_serve_stale_data: int = 0
        # 是否只读从服务器？
        #  Slave is read only?
        self.repl_slave_ro: int = 0
        # 连接断开的时长
        #  Unix time at which link with master went down
        self.repl_down_since: int = 0
        # 是否要在 SYNC 之后关闭 NODELAY ？
        #  Disable TCP_NODELAY after SYNC?
        self.repl_disable_tcp_nodelay: int = 0
        # 从服务器优先级
        #  Reported in INFO and used by Sentinel.
        self.slave_priority: int = 0
        # 本服务器（从服务器）当前主服务器的 RUN ID
        #  Master run id for PSYNC.
        self.repl_master_runid: str = ''
        # 初始化偏移量
        #  Master PSYNC offset.
        self.repl_master_initial_offset: int = 0
        #  Replication script cache.
        # 复制脚本缓存
        # 字典
        #  SHA1 all slaves are aware of.
        self.repl_scriptcache_dict: dict = {}
        # FIFO 队列
        #  First in, first out LRU eviction.
        self.repl_scriptcache_fifo: List = []
        # 缓存的大小
        #  Max number of elements.
        self.repl_scriptcache_size: int = 0
        #  Synchronous replication.
        #  Clients waiting in WAIT command.
        self.clients_waiting_acks: List = []
        #  If true we send REPLCONF GETACK.
        self.get_ack_from_slaves: int = 0
        #  Limits
        #  Max number of simultaneous clients
        self.maxclients: int = 0
        #  Max number of memory bytes to use
        self.maxmemory: int = 0
        #  Policy for key eviction
        self.maxmemory_policy: int = 0
        #  Pricision of random sampling
        self.maxmemory_samples: int = 0
'''
